---
title: LC6155 - 找出数组的第 K 大和
date: 2022-08-21 13:00:00
tags: 算法竞赛
---
**题目链接：** https://leetcode.cn/problems/find-the-k-sum-of-an-array/

**题意：** 给定一个长度为 $n$ 的数组 $a_1, a_2, \cdots, a_n$ 和正整数 $k$，可以选择数组的任意子序列并对元素求和。问它的第 $k$ 大子序列和是多少？

数组的第 $k$ 大子序列和：可以获得的第 $k$ 个最大子序列和（子序列和允许重复）。
- $1\le n\le 10^5$
- $-10^9\le a_i\le 10^9$

**题解：** 

#### 1. 从简化问题开始

首先考虑本题的简化问题：给定 $n$ 个非负数 $a_1, a_2, \cdots, a_n$，求第 $k$ 个最小的子序列和。

这是一个经典问题。我们先把所有数从小到大排序，记 $(s, i)$ 表示一个总和为 $s$，且最后一个元素是第 $i$ 个元素的子序列。

我们用一个小根堆维护 $(s, i)$，一开始堆中只有一个元素 $(a_1, 1)$。当我们取出堆顶元素 (s, i)(s,i) 时，我们可以进行以下操作：
- 把 $a_{i + 1}$ 接到这个子序列的后面形成新的子序列，也就是将 $(s + a_{i + 1}, i + 1)$ 放入堆中。
- 把子序列中的 $a_i$ 直接换成 $a_{i + 1}$，也就是将 $(s - a_i + a_{i + 1}, i + 1)$ 放入堆中。

第 $(k - 1)$ 次取出的 $(s, i)$ 中的 $s$ 就是答案，其中 $k = 1$ 时答案为空集之和，也就是 $0$。

这个做法的正确性基于以下事实：
- 这种方法能不重不漏地生成所有子序列。
- 每次放进去的数不小于拿出来的数。

#### 2. 最小和变最大和

实际上，求第 $k$ 个最大的子序列和，与求第 $k$ 的最小的子序列和是一样的。我们求出 $k$ 小子序列后取反（选择不在答案中的所有元素作为新的答案），就能得到 $k$ 大子序列。因此所有元素之和减去 $k$ 小子序列和，就能得到 $k$ 大子序列和。

#### 3. 引入负数

接下来回到原问题，考虑给定的数中有负数的情况。

首先计算 $m$ 表示所有负数的和，然后把所有负数变成它们的绝对值（这样就回到了全是非负数的情况）。答案就是 $m$ 加上 $k$ 大子序列和。

为什么这样是对的？考虑由此得到的 $k$ 大子序列，它实际上唯一对应了一个原有的子序列。我们举个例子：
- 一开始给定整数 $\{-3, -2, -1, 4, 5, 6\}$；
- 经过转换之后，我们得到 $k$ 大子序列 $\{2, 1, 5, 6\}$；
- 对于所有在该子序列中的非负数，令它成为答案的一部分，也就是说 $5$ 和 $6$ 是答案的一部分；
- 对于所有不在该子序列中的负数，令它成为答案的一部分，也就是说 $−3$ 是答案的一部分；
- 最后得到真实的答案 $\{-3, 5, 6\}$。

**代码：**
```c++
using ll = long long;

struct node {
    ll sum;
    int pos;
    
    friend bool operator< (const node& x, const node& y) {
        return x.sum > y.sum;
    }
};

class Solution {
public:
    long long kSum(vector<int>& nums, int k) {
        int n = nums.size();
        ll neg = 0, sum = 0;
        for (int i = 0; i < n; i++) {
            sum += nums[i];
            if (nums[i] < 0) {
                neg += nums[i];
                nums[i] = -nums[i];
            }
        }
        sort(begin(nums), end(nums));
        priority_queue<node> q;
        q.push({nums[0], 0});
        ll ans = 0;
        for (int i = 1; i < k; i++) {
            node now = q.top();
            q.pop();
            ans = now.sum;
            if (now.pos < n-1) {
                q.push({now.sum + nums[now.pos+1], now.pos+1});
                q.push({now.sum - nums[now.pos] + nums[now.pos+1], now.pos+1});
            }
        }
        return sum - (neg + ans);
    }
};
```