---
title: Codeforces1657C - Bracket Sequence Deletion - 贪心
date: 2022-03-31 23:51:40
tags: 算法竞赛
---
**题目链接：** https://codeforces.com/contest/1657/problem/C

**题意：** 给定一段长度为 $n$ 且只包含左括号`(`和右括号`)`的序列 $s$。定义一段好序列满足至少下面两个条件之一：
1. 该序列符合括号序列的性质，即序列中任何一个一个左括号`(`均有一个右括号`)`与之匹配。
2. 该序列是长度大于 $2$ 的回文序列。
现在从源括号序列开始，每次将删除从当前序列前缀开始最小的一段好序列直到删完或不能删了为止，问最多能操作几次，还剩下几个字符？
- $1\le n\le 5\times 10^5$

**题解：** 考虑贪心地模拟这个删除的过程，从起点出发向后枚举该段是否能删除，能删除则贪心的删除。其实是一道简单题，但是开始没想清楚回文条件应该如何判断，但其实因为括号序列的特殊性，分类讨论即可。
- 考虑当前首字符 $s[i]$ 是`(`，那么不论接下来的字符 $s[i+1]$ 是什么，前缀 $s[i..i+1]$ 所构成的子串均满足好序列定义（因为若 $s[i+1]$ 是`)`则构成`()`满足条件1，否则若 $s[i+1]$ 是`(`则构成`((`满足条件2）。
- 下面考虑当首字符 $s[i]$ 是 `)`，那么它和下一个 `)` 所包含的这一段子串（中间包含若干的`(`字符）就构成了以`)`开头和结尾的回文串。

这么一分类讨论就做法就豁然开朗了，有时候遇到看似复杂的条件却没有明显思路时候可以多试试分类讨论。

**代码：**
```c++
#include <bits/stdc++.h>
using namespace std;
const int maxn = 5e5 + 5;
char s[maxn];
int main() {
	int t, n;
	scanf("%d", &t);
	while (t--) {
		scanf("%d%s", &n, s);
		int cnt = 0, l = 0;
		while (l < n) {
			if (l < n-1 && (s[l] == '(' || (s[l] == ')' && s[l+1] == ')'))) {
				l += 2;
			} else {
				int r = l+1;
				while (r < n && s[r] != ')') r++;
				if (r == n) break;
				l = r + 1;
			}
			cnt++;
		}
		printf("%d %d\n", cnt, n - l);
	}
	return 0;
}
```